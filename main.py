from typing import List
from datetime import datetime, timezone
import sys

from helper import (
    DailyRecord,
    sort_history,
    load_history,
    save_history,
    trim_history,
    determine_start_build,
    check_downloadable,
    build_record,
    url,
    bcolors,
)
from config import CSV_PATH, FALLBACK_YEAR, FALLBACK_MONTH, SCAN_WINDOW
from cusTypes import Version, Platform
from git import fetch_latest_versions


def generate_row(version: Version) -> str:
    """Generate a markdown table row for a given version."""
    links: str = ""
    links += f"[Win (System)]({url(version, Platform.WINDOWS_SYS)})"
    links += f"| [Win (User)]({url(version, Platform.WINDOWS_USER)})"
    links += f"| [MacOS (ARM)]({url(version, Platform.MACOS_ARM)})"
    links += f"| [MacOS (x64)]({url(version, Platform.MACOS_X64)})"
    links += f"| [Deb/Ubuntu (x64)]({url(version, Platform.DEBIAN_X64)})"
    links += f"| [Deb/Ubuntu (ARM)]({url(version, Platform.DEBIAN_ARM)})"
    links += f"| [RHEL (x64)]({url(version, Platform.REDHAT_X64)})"
    links += f"| [RHEL (ARM)]({url(version, Platform.REDHAT_ARM)})"
    return f"| {str(version)} | {links} |\n"


def generate_readme(history: List[DailyRecord]):
    """Generate README.md with a table of available Positron dailies."""
    current_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    readme_content = f"""# Positron Daily Builds

This repository tracks available Positron daily builds.

## Latest Available Dailies

Last updated: {current_time}

| Version |        |       |       | Download | Links |       |       |       |
|---------|--------|-------|-------|----------|-------|-------|-------|-------|
"""

    if not history:
        readme_content += "| No builds available | - | - | - | - | - | - | - | - |\n"
    else:
        for record in reversed(sort_history(history)):
            readme_content += generate_row(record["version"])

    readme_content += "\n## About\n\n"
    readme_content += "This list is automatically generated by scanning the Positron CDN for available daily builds.\n"
    readme_content += "\n## Data persistence\n\n"
    readme_content += (
        "Daily build metadata is cached in `data/dailies.csv`, allowing the script to resume from the "
        "last recorded build and limit the history to the 30 most recent dailies for quick reference.\n"
    )

    return readme_content


def write_readme(content: str):
    """Write content to README.md file."""
    with open("README.md", "w") as f:
        f.write(content)


def main():
    history = load_history(CSV_PATH)

    # Get existing versions from history to avoid re-checking
    existing_versions: set[Version] = {record["version"] for record in history}

    # Fetch tags from GitHub
    print("Fetching version tags from GitHub...")
    tag_versions = fetch_latest_versions()

    if not tag_versions:
        raise ConnectionError("No versions found from GitHub tags. Exiting...")

    start_build = determine_start_build(history, current_month)
    latest_version: Version | None = None
    new_records: List[DailyRecord] = []

    try:
        remaining_scans = SCAN_WINDOW
        build_number = start_build

        while (current_year < FALLBACK_YEAR) or (
            current_year == FALLBACK_YEAR and current_month <= FALLBACK_MONTH
        ):
            while remaining_scans != 0:
                version = Version(current_year, current_month, build_number)
                build_url = url(version)
                match check_downloadable(build_url):
                    case 200:
                        latest_version = version
                        record = build_record(current_year, current_month, build_number)
                        history.append(record)
                        new_records.append(record)
                        print(
                            bcolors.OKGREEN
                            + f"{build_number}: downloadable: {build_url}"
                            + bcolors.ENDC
                        )
                        remaining_scans = (
                            SCAN_WINDOW + 1
                        )  # reset scan window on success

                    case 404 | 403:
                        print(f"{build_number}: not downloadable.")
                    case _:
                        print(
                            bcolors.WARNING
                            + f"{build_number}: unknown response."
                            + bcolors.ENDC
                        )
                build_number += 1  # increment build number
                remaining_scans -= 1

            print(f"Month {current_month}/{current_year} scan complete.\n")
            # end for month, reset build_number and remaining_scans
            build_number = 0
            remaining_scans = SCAN_WINDOW
            # increment month/year
            if current_month == 12:
                current_month = 1
                current_year += 1
            else:
                current_month += 1

    except KeyboardInterrupt:
        print("\nProcess interrupted by user. Exiting...")

    history = trim_history(sort_history(history))
    save_history(history, CSV_PATH)

    if latest_version is not None:
        print(f"Latest downloadable: {url(latest_version)}")

    readme_content = generate_readme(history)
    write_readme(readme_content)
    print(f"\nREADME.md generated with {len(history)} recorded version(s).")


if __name__ == "__main__":
    sys.exit(main())
