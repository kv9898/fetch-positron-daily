from typing import List
from datetime import datetime, timezone
import sys

from helper import (
    table_header,
    sort_history,
    load_history,
    save_history,
    trim_history,
    trim_availability,
    history_to_availability,
    fetch_availability,
    build_record,
    bcolors,
    README_TEMPLATE,
)
from config import CSV_PATH
from cusTypes.record import DailyAvailability
from cusTypes.version import Version
from platforms import Platform, System, Architecture
from git import fetch_latest_versions


def generate_row(availability: DailyAvailability) -> str:
    """Generate a markdown table row for a given availability object.

    Args:
        availability: DailyAvailability object.

    Returns:
        A markdown formatted table row string.
    """

    def system_links(system: System) -> str:
        text: str = system.value + "<br>"
        arch_links: list[str] = []
        for arch in Architecture:
            try:
                platform = Platform.get(system, arch)
                if not availability.available_platforms[platform]:
                    continue
                arch_links.append(
                    f"([{arch.value}]({platform.url(availability.version)}))"
                )
            except ValueError:
                pass
        if not arch_links:
            return text + "-"
        return text + " ".join(arch_links)

    links: str = "| ".join(system_links(system) for system in System)
    return f"| [{str(availability.version)}](https://github.com/posit-dev/positron/releases/tag/{str(availability.version)}) | {links} |\n"


def generate_readme(availability_list: List[DailyAvailability]) -> str:
    """Generate README.md with a table of available Positron dailies."""
    current_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    readme_content = README_TEMPLATE.format(current_time=current_time) + table_header()

    if not availability_list:
        readme_content += "| No builds available | - | - | - | - | - | - | - | - |\n"
    else:
        for availability in reversed(availability_list):
            readme_content += generate_row(availability)

    readme_content += "\n## About\n\n"
    readme_content += "This list is automatically generated by fetching the GitHub tags and scanning the Positron CDN for available daily builds.\n"
    readme_content += "\n## Data persistence\n\n"
    readme_content += (
        "Daily build metadata is cached in `data/dailies.csv`, allowing the script to resume from the "
        "last recorded build and limit the history to the 30 most recent dailies for quick reference.\n"
    )

    return readme_content


def write_readme(content: str):
    """Write content to README.md file."""
    with open("README.md", "w") as f:
        f.write(content)


def main():
    history = load_history(CSV_PATH)
    availability_list = history_to_availability(history)

    # Get existing versions from history to avoid re-checking
    existing_versions: set[Version] = {record["version"] for record in history}

    # Fetch tags from GitHub
    print("Fetching version tags from GitHub...")
    tag_versions = fetch_latest_versions()

    if not tag_versions:
        raise ConnectionError("No versions found from GitHub tags. Exiting...")

    # Filter out versions we already have in history
    new_versions = [v for v in tag_versions if v not in existing_versions]
    print(
        f"Found {len(tag_versions)} total tags, {len(new_versions)} new versions to check"
    )

    try:
        for version in new_versions:
            availability = fetch_availability(version)
            if availability is not None:
                # Add version to final display if checksums exist (even if some platforms are missing)
                record = build_record(version)
                availability_list.append(availability)
                available_count = sum(
                    1 for p in Platform if availability.available_platforms[p]
                )
                if available_count == len(Platform):
                    history.append(
                        record
                    )  # Add record to history only if all platforms are available
                print(
                    bcolors.OKGREEN
                    + f"{version}: checksums available ({available_count}/{len(Platform)} platforms)"
                    + bcolors.ENDC
                )
            else:
                print(f"{version}: checksums not available yet.")

    except KeyboardInterrupt:
        print("\nProcess interrupted by user. Exiting...")

    history = trim_history(sort_history(history))
    save_history(history, CSV_PATH)

    if history:
        print(
            f"Latest fully available version: {Platform.WINDOWS_SYS.url(history[-1]['version'])}"
        )

    availability_list = trim_availability(availability_list)

    readme_content = generate_readme(availability_list)
    write_readme(readme_content)
    print(f"\nREADME.md generated with {len(availability_list)} recorded version(s).")


if __name__ == "__main__":
    sys.exit(main())
