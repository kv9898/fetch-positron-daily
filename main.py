from typing import List
from datetime import datetime, timezone
import sys

from helper import (
    DailyRecord,
    sort_history,
    load_history,
    save_history,
    trim_history,
    trim_availability,
    history_to_availability,
    fetch_checksums,
    fetch_availability,
    is_platform_available,
    build_record,
    url,
    bcolors,
    README_TEMPLATE,
)
from config import CSV_PATH
from cusTypes import Version
from platforms import Platform
from git import fetch_latest_versions


def generate_row(version: Version, checksums: dict) -> str:
    """Generate a markdown table row for a given version with availability checks.

    Args:
        version: Version to generate row for.
        checksums: Dictionary containing checksum data for the version.

    Returns:
        A markdown formatted table row string.
    """

    def platform_link(platform: Platform, label: str) -> str:
        if is_platform_available(checksums, version, platform):
            return f"[{label}]({url(version, platform)})"
        return "-"

    links: str = ""
    links += platform_link(Platform.WINDOWS_SYS, "Win (System)")
    links += "| " + platform_link(Platform.WINDOWS_USER, "Win (User)")
    links += "| " + platform_link(Platform.MACOS_ARM, "MacOS (ARM)")
    links += "| " + platform_link(Platform.MACOS_X64, "MacOS (x64)")
    links += "| " + platform_link(Platform.DEBIAN_X64, "Deb/Ubuntu (x64)")
    links += "| " + platform_link(Platform.DEBIAN_ARM, "Deb/Ubuntu (ARM)")
    links += "| " + platform_link(Platform.REDHAT_X64, "RHEL (x64)")
    links += "| " + platform_link(Platform.REDHAT_ARM, "RHEL (ARM)")
    return f"| [{str(version)}](https://github.com/posit-dev/positron/releases/tag/{str(version)}) | {links} |\n"


def generate_readme(history: List[DailyRecord]):
    """Generate README.md with a table of available Positron dailies."""
    current_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    readme_content = README_TEMPLATE.format(current_time=current_time)

    if not history:
        readme_content += "| No builds available | - | - | - | - | - | - | - | - |\n"
    else:
        for record in reversed(sort_history(history)):
            version = record["version"]
            checksums = fetch_checksums(version)
            if checksums:
                readme_content += generate_row(version, checksums)

    readme_content += "\n## About\n\n"
    readme_content += "This list is automatically generated by fetching the Github tags and scanning the Positron CDN for available daily builds.\n"
    readme_content += "\n## Data persistence\n\n"
    readme_content += (
        "Daily build metadata is cached in `data/dailies.csv`, allowing the script to resume from the "
        "last recorded build and limit the history to the 30 most recent dailies for quick reference.\n"
    )

    return readme_content


def write_readme(content: str):
    """Write content to README.md file."""
    with open("README.md", "w") as f:
        f.write(content)


def main():
    history = load_history(CSV_PATH)
    availability_list = history_to_availability(history)

    # Get existing versions from history to avoid re-checking
    existing_versions: set[Version] = {record["version"] for record in history}

    # Fetch tags from GitHub
    print("Fetching version tags from GitHub...")
    tag_versions = fetch_latest_versions()

    if not tag_versions:
        raise ConnectionError("No versions found from GitHub tags. Exiting...")

    # Filter out versions we already have in history
    new_versions = [v for v in tag_versions if v not in existing_versions]
    print(
        f"Found {len(tag_versions)} total tags, {len(new_versions)} new versions to check"
    )

    try:
        for version in new_versions:
            availability = fetch_availability(version)
            if availability is not None:
                # Add version if checksums exist (even if some platforms are missing)
                record = build_record(version)
                availability_list.append(availability)
                available_count = sum(
                    1 for p in Platform if availability.available_platforms[p]
                )
                if available_count == len(Platform):
                    history.append(record) # Add record to history only if all platforms are available
                print(
                    bcolors.OKGREEN
                    + f"{version}: checksums available ({available_count}/{len(Platform)} platforms)"
                    + bcolors.ENDC
                )
            else:
                print(f"{version}: checksums not available yet.")

    except KeyboardInterrupt:
        print("\nProcess interrupted by user. Exiting...")

    history = trim_history(sort_history(history))
    save_history(history, CSV_PATH)

    if history is not None:
        print(f"Latest fully available version: {url(history[-1]['version'])}")

    availability_list = trim_availability(availability_list)

    readme_content = generate_readme(history)
    write_readme(readme_content)
    print(f"\nREADME.md generated with {len(history)} recorded version(s).")


if __name__ == "__main__":
    sys.exit(main())
