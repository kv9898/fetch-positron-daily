from typing import List
from datetime import datetime, timezone
import sys

from helper import (
    DailyRecord,
    sort_history,
    load_history,
    save_history,
    trim_history,
    check_downloadable,
    build_record,
    url,
    bcolors,
)
from config import CSV_PATH
from cusTypes import Version, Platform
from git import fetch_latest_versions


def generate_row(version: Version) -> str:
    """Generate a markdown table row for a given version."""
    links: str = ""
    links += f"[Win (System)]({url(version, Platform.WINDOWS_SYS)})"
    links += f"| [Win (User)]({url(version, Platform.WINDOWS_USER)})"
    links += f"| [MacOS (ARM)]({url(version, Platform.MACOS_ARM)})"
    links += f"| [MacOS (x64)]({url(version, Platform.MACOS_X64)})"
    links += f"| [Deb/Ubuntu (x64)]({url(version, Platform.DEBIAN_X64)})"
    links += f"| [Deb/Ubuntu (ARM)]({url(version, Platform.DEBIAN_ARM)})"
    links += f"| [RHEL (x64)]({url(version, Platform.REDHAT_X64)})"
    links += f"| [RHEL (ARM)]({url(version, Platform.REDHAT_ARM)})"
    return f"| {str(version)} | {links} |\n"


def generate_readme(history: List[DailyRecord]):
    """Generate README.md with a table of available Positron dailies."""
    current_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    readme_content = f"""# Positron Daily Builds

This repository tracks available Positron daily builds.

## Latest Available Dailies

Last updated: {current_time}

| Version |        |       |       | Download | Links |       |       |       |
|---------|--------|-------|-------|----------|-------|-------|-------|-------|
"""

    if not history:
        readme_content += "| No builds available | - | - | - | - | - | - | - | - |\n"
    else:
        for record in reversed(sort_history(history)):
            readme_content += generate_row(record["version"])

    readme_content += "\n## About\n\n"
    readme_content += "This list is automatically generated by scanning the Positron CDN for available daily builds.\n"
    readme_content += "\n## Data persistence\n\n"
    readme_content += (
        "Daily build metadata is cached in `data/dailies.csv`, allowing the script to resume from the "
        "last recorded build and limit the history to the 30 most recent dailies for quick reference.\n"
    )

    return readme_content


def write_readme(content: str):
    """Write content to README.md file."""
    with open("README.md", "w") as f:
        f.write(content)


def main():
    history = load_history(CSV_PATH)

    # Get existing versions from history to avoid re-checking
    existing_versions: set[Version] = {record["version"] for record in history}

    # Fetch tags from GitHub
    print("Fetching version tags from GitHub...")
    tag_versions = fetch_latest_versions()

    if not tag_versions:
        raise ConnectionError("No versions found from GitHub tags. Exiting...")

    # Filter out versions we already have in history
    new_versions = [v for v in tag_versions if v not in existing_versions]
    print(f"Found {len(tag_versions)} total tags, {len(new_versions)} new versions to check")

    try:
        for version in new_versions:
            build_url = url(version)
            match check_downloadable(url(version)):
                case 200:
                    record = build_record(version.year, version.month, version.number)
                    history.append(record)
                    print(
                        bcolors.OKGREEN
                        + f"{version.number}: downloadable: {build_url}"
                        + bcolors.ENDC
                    )

                case 404 | 403:
                    print(f"{version}: not downloadable.")
                case _:
                    print(
                        bcolors.WARNING
                        + f"{version}: unknown response."
                        + bcolors.ENDC
                    )

    except KeyboardInterrupt:
        print("\nProcess interrupted by user. Exiting...")

    history = trim_history(sort_history(history))
    save_history(history, CSV_PATH)

    if history is not None:
        print(f"Latest downloadable: {url(history[-1]['version'])}")

    readme_content = generate_readme(history)
    write_readme(readme_content)
    print(f"\nREADME.md generated with {len(history)} recorded version(s).")


if __name__ == "__main__":
    sys.exit(main())
