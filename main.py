from typing import List
from datetime import datetime, timezone

from helper import (
    DailyRecord,
    sort_history,
    load_history,
    save_history,
    trim_history,
    determine_start_build,
    check_downloadable,
    build_record,
    url,
    bcolors,
)
from config import CSV_PATH, FALLBACK_YEAR, FALLBACK_MONTH, SCAN_WINDOW
from cusTypes import Version, Platform


def generate_row(version: Version) -> str:
    """Generate a markdown table row for a given version."""
    links: str = ""
    links += f"[Windows (System)]({url(version, Platform.WINDOWS_SYS)})"
    links += f" [Windows (User)]({url(version, Platform.WINDOWS_USER)})"
    links += f" [MacOS (ARM)]({url(version, Platform.MACOS_ARM)})"
    links += f" [MacOS (x64)]({url(version, Platform.MACOS_X64)})"
    links += f" [Debian (x64)]({url(version, Platform.DEBIAN_X64)})"
    links += f" [Debian (ARM)]({url(version, Platform.DEBIAN_ARM)})"
    return f"| {str(version)} | {links} |\n"


def generate_readme(history: List[DailyRecord]):
    """Generate README.md with a table of available Positron dailies."""
    current_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    readme_content = f"""# Positron Daily Builds

This repository tracks available Positron daily builds.

## Latest Available Dailies

Last updated: {current_time}

| Version | Download Link |
|---------|---------------|
"""

    if not history:
        readme_content += "| No builds available | - | - | - |\n"
    else:
        for record in reversed(sort_history(history)):
            readme_content += generate_row(record["version"])

    readme_content += "\n## About\n\n"
    readme_content += "This list is automatically generated by scanning the Positron CDN for available daily builds.\n"
    readme_content += "\n## Data persistence\n\n"
    readme_content += (
        "Daily build metadata is cached in `data/dailies.csv`, allowing the script to resume from the "
        "last recorded build and limit the history to the 30 most recent dailies for quick reference.\n"
    )

    return readme_content


def write_readme(content: str):
    """Write content to README.md file."""
    with open("README.md", "w") as f:
        f.write(content)


def main():
    history = load_history(CSV_PATH)
    # determine the current month from the latest CSV record if present,
    # otherwise fall back to the configured default month
    if history:
        current_year = history[-1]["version"].year
        current_month = history[-1]["version"].month
    else:
        current_year = FALLBACK_YEAR
        current_month = FALLBACK_MONTH

    start_build = determine_start_build(history, current_month)
    latest_version: Version | None = None
    new_records: List[DailyRecord] = []

    try:
        remaining_scans = SCAN_WINDOW
        build_number = start_build

        while (current_year < FALLBACK_YEAR) or (
            current_year == FALLBACK_YEAR and current_month <= FALLBACK_MONTH
        ):
            while remaining_scans != 0:
                version = Version(current_year, current_month, build_number)
                build_url = url(version)
                match check_downloadable(build_url):
                    case 200:
                        latest_version = version
                        record = build_record(current_year, current_month, build_number)
                        history.append(record)
                        new_records.append(record)
                        print(
                            bcolors.OKGREEN
                            + f"{build_number}: downloadable: {build_url}"
                            + bcolors.ENDC
                        )
                        remaining_scans = (
                            SCAN_WINDOW + 1
                        )  # reset scan window on success

                    case 404 | 403:
                        print(f"{build_number}: not downloadable.")
                    case _:
                        print(
                            bcolors.WARNING
                            + f"{build_number}: unknown response."
                            + bcolors.ENDC
                        )
                build_number += 1  # increment build number
                remaining_scans -= 1

            print(f"Month {current_month}/{current_year} scan complete.\n")
            # end for month, reset build_number and remaining_scans
            build_number = 0
            remaining_scans = SCAN_WINDOW
            # increment month/year
            if current_month == 12:
                current_month = 1
                current_year += 1
            else:
                current_month += 1

    except KeyboardInterrupt:
        print("\nProcess interrupted by user. Exiting...")

    history = trim_history(sort_history(history))
    save_history(history, CSV_PATH)

    if latest_version is not None:
        print(f"Latest downloadable: {url(latest_version)}")

    readme_content = generate_readme(history)
    write_readme(readme_content)
    print(f"\nREADME.md generated with {len(history)} recorded version(s).")


if __name__ == "__main__":
    main()
